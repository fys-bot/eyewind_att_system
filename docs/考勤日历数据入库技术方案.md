# 考勤日历数据入库技术方案

## 1. 背景与目标

### 1.1 背景
当前考勤日历数据存储在浏览器缓存（SmartCache/IndexedDB）中，存在以下问题：
- 数据无法跨设备同步，换设备需重新拉取
- 无法进行历史数据追溯和分析
- 缺乏数据备份和恢复机制
- 无法支持多用户协作查看和编辑
- 数据量大时缓存性能下降

### 1.2 目标
- 将考勤日历数据持久化到数据库
- 支持按月份、公司、员工维度查询
- 实现考勤数据的增量同步
- 支持手动修改记录的审计追踪
- 保持与现有前端的兼容性

---

## 2. 现有数据结构分析

### 2.1 核心数据类型

| 类型 | 说明 | 来源 |
|------|------|------|
| `AttendanceMap` | 考勤数据主结构 | `Record<userId, Record<day, DailyAttendanceStatus>>` |
| `DailyAttendanceStatus` | 每日考勤状态 | 包含打卡记录、异常标记等 |
| `PunchRecord` | 打卡记录 | 钉钉API或手动编辑 |
| `EmployeeStats` | 员工月度统计 | 前端计算生成 |
| `processDataMap` | 审批单详情缓存 | 钉钉审批API |

### 2.2 DailyAttendanceStatus 结构

```typescript
interface DailyAttendanceStatus {
    status: 'normal' | 'abnormal' | 'incomplete' | 'noRecord';
    records: PunchRecord[];
    onDutyTime?: string;      // 上班打卡时间
    offDutyTime?: string;     // 下班打卡时间
    hasAbnormality: boolean;  // 是否有异常
    hasOffDutyApprove: boolean;
    hasOnDutyApprove: boolean;
}
```

### 2.3 PunchRecord 结构

```typescript
interface PunchRecord {
    userId: string;
    workDate: number;         // 工作日期时间戳
    checkType: 'OnDuty' | 'OffDuty';
    sourceType: string;       // 'ATM', 'APPROVE', 'MANUAL_EDIT'
    timeResult: 'Normal' | 'Late' | 'Early' | 'NotSigned' | 'SeriousLate' | 'Absenteeism';
    locationResult: 'Normal' | 'Outside' | 'NotSigned';
    userCheckTime: number;    // 实际打卡时间戳
    baseCheckTime: number;    // 基准打卡时间戳
    procInstId?: string;      // 关联审批单ID
    groupId?: string;
    planId?: string;
    approveId?: string;
    corpId?: string;
    sourceType_Desc?: string;
    checkType_Desc?: string;
    timeResult_Desc?: string;
}
```

### 2.4 EmployeeStats 结构

```typescript
interface EmployeeStats {
    // 异常统计
    late: number;              // 迟到次数
    missing: number;           // 缺卡次数
    absenteeism: number;       // 旷工次数
    lateMinutes: number;       // 迟到总分钟数
    exemptedLateMinutes: number; // 豁免后迟到分钟数
    exemptedLate?: number;     // 豁免迟到次数
    performancePenalty?: number; // 绩效扣款
    monthlyExemptionUsed?: number;
    
    // 请假统计（次数）
    annual: number;
    sick: number;
    seriousSick: number;
    personal: number;
    trip: number;
    compTime: number;
    bereavement?: number;
    paternity?: number;
    maternity?: number;
    parental?: number;
    marriage?: number;
    
    // 请假统计（小时数）
    annualHours: number;
    sickHours: number;
    seriousSickHours: number;
    personalHours: number;
    tripHours: number;
    compTimeHours: number;
    bereavementHours?: number;
    paternityHours?: number;
    maternityHours?: number;
    parentalHours?: number;
    marriageHours?: number;
    
    // 出勤统计
    isFullAttendance?: boolean;
    shouldAttendanceDays?: number;
    actualAttendanceDays?: number;
    
    // 加班统计
    overtimeTotalMinutes?: number;
    overtime19_5Minutes?: number;
    overtime20_5Minutes?: number;
    overtime22Minutes?: number;
    overtime24Minutes?: number;
    overtime19_5Count?: number;
    overtime20_5Count?: number;
    overtime22Count?: number;
    overtime24Count?: number;
}
```

---

## 3. 数据库设计

### 3.1 ER 图

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        attendance_daily (每日考勤主表)                        │
│  - 员工每日考勤状态汇总                                                        │
│  - 上下班时间、异常标记                                                        │
└─────────────────────────────────────────────────────────────────────────────┘
          │
          │ 1:N
          ▼
┌──────────────────────────────────────────────────────────────────────────────┐
│                        punch_record (打卡记录表)                               │
│  - 每条打卡记录详情                                                            │
│  - 支持多次打卡、审批补卡                                                       │
└──────────────────────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────────────────────┐
│                        attendance_monthly_stats (月度统计表)                   │
│  - 员工月度考勤统计汇总                                                        │
│  - 迟到、请假、加班等统计                                                       │
└──────────────────────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────────────────────┐
│                        approval_record (审批单缓存表)                          │
│  - 钉钉审批单详情缓存                                                          │
│  - 减少重复API调用                                                             │
└──────────────────────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────────────────────┐
│                        attendance_edit_log (编辑日志表)                        │
│  - 手动修改考勤的审计日志                                                       │
│  - 支持追溯和回滚                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 表结构设计

#### 3.2.1 每日考勤主表 (attendance_daily)

```sql
CREATE TABLE attendance_daily (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    company_id VARCHAR(64) NOT NULL COMMENT '公司标识',
    user_id VARCHAR(64) NOT NULL COMMENT '员工ID',
    user_name VARCHAR(128) COMMENT '员工姓名（冗余）',
    department VARCHAR(256) COMMENT '部门（冗余）',
    
    -- 日期信息
    attendance_date DATE NOT NULL COMMENT '考勤日期',
    year_month VARCHAR(7) NOT NULL COMMENT '年月，如 2026-01',
    day_of_week TINYINT COMMENT '星期几 (0=周日, 1-6)',
    is_workday BOOLEAN DEFAULT TRUE COMMENT '是否工作日',
    is_holiday BOOLEAN DEFAULT FALSE COMMENT '是否法定节假日',
    holiday_name VARCHAR(64) COMMENT '节假日名称',
    
    -- 考勤状态
    status ENUM('normal','abnormal','incomplete','noRecord') NOT NULL DEFAULT 'noRecord' COMMENT '考勤状态',
    has_abnormality BOOLEAN DEFAULT FALSE COMMENT '是否有异常',
    has_on_duty_approve BOOLEAN DEFAULT FALSE COMMENT '上班是否有审批',
    has_off_duty_approve BOOLEAN DEFAULT FALSE COMMENT '下班是否有审批',
    
    -- 打卡时间
    on_duty_time TIME COMMENT '上班打卡时间',
    off_duty_time TIME COMMENT '下班打卡时间',
    on_duty_timestamp BIGINT COMMENT '上班打卡时间戳',
    off_duty_timestamp BIGINT COMMENT '下班打卡时间戳',
    
    -- 异常信息
    late_minutes INT DEFAULT 0 COMMENT '迟到分钟数',
    is_late BOOLEAN DEFAULT FALSE COMMENT '是否迟到',
    is_missing BOOLEAN DEFAULT FALSE COMMENT '是否缺卡',
    is_absenteeism BOOLEAN DEFAULT FALSE COMMENT '是否旷工',
    
    -- 请假信息
    leave_type VARCHAR(32) COMMENT '请假类型',
    leave_hours DECIMAL(4,2) DEFAULT 0 COMMENT '请假时长（小时）',
    leave_proc_inst_id VARCHAR(64) COMMENT '请假审批单ID',
    
    -- 加班信息
    overtime_minutes INT DEFAULT 0 COMMENT '加班分钟数',
    overtime_checkpoint VARCHAR(16) COMMENT '加班节点（19:30/20:30/22:00/24:00）',
    
    -- 元数据
    data_source ENUM('dingtalk','manual','import') DEFAULT 'dingtalk' COMMENT '数据来源',
    sync_time DATETIME COMMENT '最后同步时间',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    UNIQUE KEY uk_company_user_date (company_id, user_id, attendance_date),
    INDEX idx_company_month (company_id, year_month),
    INDEX idx_user_month (user_id, year_month),
    INDEX idx_date (attendance_date),
    INDEX idx_status (status)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='每日考勤主表';
```

#### 3.2.2 打卡记录表 (punch_record)

```sql
CREATE TABLE punch_record (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    daily_id BIGINT NOT NULL COMMENT '关联每日考勤ID',
    company_id VARCHAR(64) NOT NULL COMMENT '公司标识',
    user_id VARCHAR(64) NOT NULL COMMENT '员工ID',
    
    -- 打卡信息
    work_date DATE NOT NULL COMMENT '工作日期',
    work_date_timestamp BIGINT NOT NULL COMMENT '工作日期时间戳',
    check_type ENUM('OnDuty','OffDuty') NOT NULL COMMENT '打卡类型',
    source_type VARCHAR(32) NOT NULL COMMENT '来源类型：ATM/APPROVE/MANUAL_EDIT',
    
    -- 时间信息
    user_check_time BIGINT NOT NULL COMMENT '实际打卡时间戳',
    base_check_time BIGINT NOT NULL COMMENT '基准打卡时间戳',
    check_time TIME COMMENT '打卡时间（便于查询）',
    
    -- 结果信息
    time_result ENUM('Normal','Late','Early','NotSigned','SeriousLate','Absenteeism') NOT NULL COMMENT '时间结果',
    location_result ENUM('Normal','Outside','NotSigned') DEFAULT 'Normal' COMMENT '位置结果',
    
    -- 关联信息
    proc_inst_id VARCHAR(64) COMMENT '审批实例ID',
    group_id VARCHAR(64) COMMENT '考勤组ID',
    plan_id VARCHAR(64) COMMENT '排班ID',
    approve_id VARCHAR(64) COMMENT '审批ID',
    corp_id VARCHAR(64) COMMENT '企业ID',
    
    -- 描述信息
    source_type_desc VARCHAR(64) COMMENT '来源类型描述',
    check_type_desc VARCHAR(32) COMMENT '打卡类型描述',
    time_result_desc VARCHAR(32) COMMENT '时间结果描述',
    
    -- 元数据
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    
    INDEX idx_daily_id (daily_id),
    INDEX idx_company_user_date (company_id, user_id, work_date),
    INDEX idx_proc_inst_id (proc_inst_id),
    FOREIGN KEY (daily_id) REFERENCES attendance_daily(id) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='打卡记录表';
```

#### 3.2.3 月度统计表 (attendance_monthly_stats)

```sql
CREATE TABLE attendance_monthly_stats (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    company_id VARCHAR(64) NOT NULL COMMENT '公司标识',
    user_id VARCHAR(64) NOT NULL COMMENT '员工ID',
    user_name VARCHAR(128) COMMENT '员工姓名',
    department VARCHAR(256) COMMENT '部门',
    year_month VARCHAR(7) NOT NULL COMMENT '年月，如 2026-01',
    
    -- 出勤统计
    should_attendance_days INT DEFAULT 0 COMMENT '应出勤天数',
    actual_attendance_days INT DEFAULT 0 COMMENT '实际出勤天数',
    is_full_attendance BOOLEAN DEFAULT FALSE COMMENT '是否全勤',
    
    -- 异常统计
    late_count INT DEFAULT 0 COMMENT '迟到次数',
    late_minutes INT DEFAULT 0 COMMENT '迟到总分钟数',
    exempted_late_count INT DEFAULT 0 COMMENT '豁免迟到次数',
    exempted_late_minutes INT DEFAULT 0 COMMENT '豁免后迟到分钟数',
    missing_count INT DEFAULT 0 COMMENT '缺卡次数',
    absenteeism_count INT DEFAULT 0 COMMENT '旷工次数',
    
    -- 绩效
    performance_penalty DECIMAL(10,2) DEFAULT 0 COMMENT '绩效扣款',
    full_attendance_bonus DECIMAL(10,2) DEFAULT 0 COMMENT '全勤奖金',
    
    -- 请假统计（次数）
    annual_count INT DEFAULT 0 COMMENT '年假次数',
    sick_count INT DEFAULT 0 COMMENT '病假次数',
    serious_sick_count INT DEFAULT 0 COMMENT '病假(>24h)次数',
    personal_count INT DEFAULT 0 COMMENT '事假次数',
    trip_count INT DEFAULT 0 COMMENT '出差次数',
    comp_time_count INT DEFAULT 0 COMMENT '调休次数',
    bereavement_count INT DEFAULT 0 COMMENT '丧假次数',
    paternity_count INT DEFAULT 0 COMMENT '陪产假次数',
    maternity_count INT DEFAULT 0 COMMENT '产假次数',
    parental_count INT DEFAULT 0 COMMENT '育儿假次数',
    marriage_count INT DEFAULT 0 COMMENT '婚假次数',
    
    -- 请假统计（小时数）
    annual_hours DECIMAL(6,2) DEFAULT 0 COMMENT '年假小时数',
    sick_hours DECIMAL(6,2) DEFAULT 0 COMMENT '病假小时数',
    serious_sick_hours DECIMAL(6,2) DEFAULT 0 COMMENT '病假(>24h)小时数',
    personal_hours DECIMAL(6,2) DEFAULT 0 COMMENT '事假小时数',
    trip_hours DECIMAL(6,2) DEFAULT 0 COMMENT '出差小时数',
    comp_time_hours DECIMAL(6,2) DEFAULT 0 COMMENT '调休小时数',
    bereavement_hours DECIMAL(6,2) DEFAULT 0 COMMENT '丧假小时数',
    paternity_hours DECIMAL(6,2) DEFAULT 0 COMMENT '陪产假小时数',
    maternity_hours DECIMAL(6,2) DEFAULT 0 COMMENT '产假小时数',
    parental_hours DECIMAL(6,2) DEFAULT 0 COMMENT '育儿假小时数',
    marriage_hours DECIMAL(6,2) DEFAULT 0 COMMENT '婚假小时数',
    
    -- 加班统计
    overtime_total_minutes INT DEFAULT 0 COMMENT '加班总分钟数',
    overtime_19_5_minutes INT DEFAULT 0 COMMENT '19:30加班分钟数',
    overtime_20_5_minutes INT DEFAULT 0 COMMENT '20:30加班分钟数',
    overtime_22_minutes INT DEFAULT 0 COMMENT '22:00加班分钟数',
    overtime_24_minutes INT DEFAULT 0 COMMENT '24:00加班分钟数',
    overtime_19_5_count INT DEFAULT 0 COMMENT '19:30加班次数',
    overtime_20_5_count INT DEFAULT 0 COMMENT '20:30加班次数',
    overtime_22_count INT DEFAULT 0 COMMENT '22:00加班次数',
    overtime_24_count INT DEFAULT 0 COMMENT '24:00加班次数',
    
    -- 备注
    remarks TEXT COMMENT '备注信息（JSON格式存储异常明细）',
    
    -- 元数据
    calc_time DATETIME COMMENT '统计计算时间',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    UNIQUE KEY uk_company_user_month (company_id, user_id, year_month),
    INDEX idx_company_month (company_id, year_month),
    INDEX idx_user_month (user_id, year_month),
    INDEX idx_full_attendance (is_full_attendance)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='月度考勤统计表';
```

#### 3.2.4 审批单缓存表 (approval_record)

```sql
CREATE TABLE approval_record (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    proc_inst_id VARCHAR(64) NOT NULL COMMENT '审批实例ID',
    company_id VARCHAR(64) NOT NULL COMMENT '公司标识',
    
    -- 审批基本信息
    title VARCHAR(256) COMMENT '审批标题',
    biz_type VARCHAR(64) COMMENT '业务类型',
    status VARCHAR(32) COMMENT '审批状态',
    
    -- 申请人信息
    applicant_user_id VARCHAR(64) COMMENT '申请人ID',
    applicant_name VARCHAR(128) COMMENT '申请人姓名',
    
    -- 表单数据（JSON）
    form_values JSON COMMENT '表单值',
    
    -- 请假相关字段（从form_values提取，便于查询）
    leave_type VARCHAR(32) COMMENT '请假类型',
    start_time DATETIME COMMENT '开始时间',
    end_time DATETIME COMMENT '结束时间',
    duration DECIMAL(6,2) COMMENT '时长',
    duration_unit VARCHAR(16) COMMENT '时长单位：day/hour',
    reason TEXT COMMENT '请假原因',
    
    -- 元数据
    fetch_time DATETIME COMMENT '获取时间',
    raw_data JSON COMMENT '原始API响应',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    UNIQUE KEY uk_proc_inst_id (proc_inst_id),
    INDEX idx_company_id (company_id),
    INDEX idx_applicant (applicant_user_id),
    INDEX idx_leave_type (leave_type),
    INDEX idx_time_range (start_time, end_time)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='审批单缓存表';
```

#### 3.2.5 编辑日志表 (attendance_edit_log)

```sql
CREATE TABLE attendance_edit_log (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    company_id VARCHAR(64) NOT NULL COMMENT '公司标识',
    user_id VARCHAR(64) NOT NULL COMMENT '被修改员工ID',
    user_name VARCHAR(128) COMMENT '被修改员工姓名',
    attendance_date DATE NOT NULL COMMENT '考勤日期',
    
    -- 修改信息
    edit_type ENUM('status','time','leave','clear','batch') NOT NULL COMMENT '修改类型',
    old_status VARCHAR(32) COMMENT '修改前状态',
    new_status VARCHAR(32) COMMENT '修改后状态',
    old_value JSON COMMENT '修改前完整数据',
    new_value JSON COMMENT '修改后完整数据',
    
    -- 关联审批单（如果是关联审批修改）
    linked_proc_inst_id VARCHAR(64) COMMENT '关联的审批单ID',
    
    -- 操作信息
    edit_reason VARCHAR(512) COMMENT '修改原因',
    editor_id VARCHAR(64) NOT NULL COMMENT '操作人ID',
    editor_name VARCHAR(128) COMMENT '操作人姓名',
    edit_time DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',
    
    -- IP和设备信息（审计用）
    client_ip VARCHAR(64) COMMENT '客户端IP',
    user_agent VARCHAR(512) COMMENT '用户代理',
    
    INDEX idx_company_date (company_id, attendance_date),
    INDEX idx_user_date (user_id, attendance_date),
    INDEX idx_editor (editor_id),
    INDEX idx_edit_time (edit_time)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='考勤编辑日志表';
```

---

## 4. API 接口设计

### 4.1 RESTful API 规范

| 方法 | 路径 | 说明 |
|------|------|------|
| GET | `/api/v1/attendance/calendar/{companyId}/{yearMonth}` | 获取月度考勤日历数据 |
| GET | `/api/v1/attendance/calendar/{companyId}/{yearMonth}/{userId}` | 获取单个员工月度数据 |
| PUT | `/api/v1/attendance/daily/{companyId}` | 批量更新每日考勤 |
| PATCH | `/api/v1/attendance/daily/{dailyId}` | 更新单条每日考勤 |
| POST | `/api/v1/attendance/sync/{companyId}/{yearMonth}` | 触发数据同步 |
| GET | `/api/v1/attendance/stats/{companyId}/{yearMonth}` | 获取月度统计 |
| POST | `/api/v1/attendance/stats/recalc/{companyId}/{yearMonth}` | 重新计算统计 |
| GET | `/api/v1/attendance/edit-logs/{companyId}` | 获取编辑日志 |
| GET | `/api/v1/approval/{procInstId}` | 获取审批单详情 |

### 4.2 接口详细设计

#### 4.2.1 获取月度考勤日历

```http
GET /api/v1/attendance/calendar/{companyId}/{yearMonth}?userIds=xxx,yyy&departments=xxx
Authorization: Bearer {token}

Response 200:
{
    "code": 0,
    "data": {
        "companyId": "fengyan",
        "yearMonth": "2026-01",
        "daysInMonth": 31,
        "attendanceMap": {
            "user001": {
                "1": {
                    "status": "normal",
                    "onDutyTime": "08:55",
                    "offDutyTime": "18:35",
                    "hasAbnormality": false,
                    "records": [...]
                },
                "2": {...}
            }
        },
        "processDataMap": {
            "proc_xxx": {
                "title": "张三提交的年假申请",
                "formValues": {...}
            }
        },
        "syncTime": "2026-01-30T10:00:00Z"
    }
}
```

#### 4.2.2 更新每日考勤

```http
PATCH /api/v1/attendance/daily/{dailyId}
Authorization: Bearer {token}
Content-Type: application/json

Request Body:
{
    "status": "normal",
    "onDutyTime": "09:00",
    "offDutyTime": "18:30",
    "records": [...],
    "linkedProcInstId": "proc_xxx",
    "editReason": "关联审批单补卡"
}

Response 200:
{
    "code": 0,
    "data": {
        "dailyId": 12345,
        "editLogId": 67890,
        "updatedAt": "2026-01-30T11:00:00Z"
    }
}
```

#### 4.2.3 触发数据同步

```http
POST /api/v1/attendance/sync/{companyId}/{yearMonth}
Authorization: Bearer {token}
Content-Type: application/json

Request Body:
{
    "syncType": "full",  // full=全量同步, incremental=增量同步
    "userIds": ["user001", "user002"],  // 可选，指定员工
    "forceRefresh": false  // 是否强制刷新缓存
}

Response 200:
{
    "code": 0,
    "data": {
        "taskId": "sync_task_xxx",
        "status": "processing",
        "totalUsers": 50,
        "processedUsers": 0,
        "estimatedTime": 120  // 预计耗时（秒）
    }
}
```

#### 4.2.4 获取月度统计

```http
GET /api/v1/attendance/stats/{companyId}/{yearMonth}?sortBy=penalty&order=desc
Authorization: Bearer {token}

Response 200:
{
    "code": 0,
    "data": {
        "companyId": "fengyan",
        "yearMonth": "2026-01",
        "totalEmployees": 50,
        "fullAttendanceCount": 35,
        "stats": [
            {
                "userId": "user001",
                "userName": "张三",
                "department": "技术部",
                "shouldAttendanceDays": 22,
                "actualAttendanceDays": 21,
                "lateCount": 2,
                "lateMinutes": 25,
                "exemptedLateMinutes": 10,
                "performancePenalty": 50,
                "isFullAttendance": false,
                "remarks": ["迟到: 2026-01-05 (15分钟)", "事假: 2026-01-10 (4小时)"]
            }
        ],
        "calcTime": "2026-01-30T10:00:00Z"
    }
}
```

### 4.3 错误码定义

| 错误码 | 说明 |
|--------|------|
| 40001 | 数据不存在 |
| 40002 | 参数校验失败 |
| 40003 | 同步任务进行中 |
| 40004 | 审批单获取失败 |
| 40005 | 无权限操作 |
| 50001 | 钉钉API调用失败 |
| 50002 | 数据库操作失败 |

---

## 5. 数据同步策略

### 5.1 同步流程图

```
┌─────────────────────────────────────────────────────────────────┐
│                        数据同步流程                               │
└─────────────────────────────────────────────────────────────────┘

  ┌──────────┐     ┌──────────┐     ┌──────────┐     ┌──────────┐
  │ 1. 触发  │ ──▶ │ 2. 拉取  │ ──▶ │ 3. 转换  │ ──▶ │ 4. 存储  │
  │ 同步任务 │     │ 钉钉数据 │     │ 数据格式 │     │ 数据库   │
  └──────────┘     └──────────┘     └──────────┘     └──────────┘
                                                           │
                                                           ▼
                                    ┌──────────┐     ┌──────────┐
                                    │ 6. 通知  │ ◀── │ 5. 计算  │
                                    │ 前端刷新 │     │ 月度统计 │
                                    └──────────┘     └──────────┘
```

### 5.2 同步服务实现

```typescript
// services/attendanceSyncService.ts

interface SyncTask {
    taskId: string;
    companyId: string;
    yearMonth: string;
    status: 'pending' | 'processing' | 'completed' | 'failed';
    totalUsers: number;
    processedUsers: number;
    startTime: Date;
    endTime?: Date;
    error?: string;
}

class AttendanceSyncService {
    private activeTasks: Map<string, SyncTask> = new Map();
    
    async startSync(companyId: string, yearMonth: string, options: {
        syncType: 'full' | 'incremental';
        userIds?: string[];
        forceRefresh?: boolean;
    }): Promise<SyncTask> {
        const taskKey = `${companyId}_${yearMonth}`;
        
        // 检查是否有进行中的任务
        const existingTask = this.activeTasks.get(taskKey);
        if (existingTask && existingTask.status === 'processing') {
            throw new Error('同步任务进行中');
        }
        
        const task: SyncTask = {
            taskId: `sync_${Date.now()}`,
            companyId,
            yearMonth,
            status: 'pending',
            totalUsers: 0,
            processedUsers: 0,
            startTime: new Date()
        };
        
        this.activeTasks.set(taskKey, task);
        
        // 异步执行同步
        this.executeSync(task, options).catch(err => {
            task.status = 'failed';
            task.error = err.message;
        });
        
        return task;
    }
    
    private async executeSync(task: SyncTask, options: any): Promise<void> {
        task.status = 'processing';
        
        try {
            // 1. 获取员工列表
            const users = options.userIds 
                ? await this.getUsersByIds(task.companyId, options.userIds)
                : await this.getAllUsers(task.companyId);
            
            task.totalUsers = users.length;
            
            // 2. 解析年月
            const [year, month] = task.yearMonth.split('-').map(Number);
            const daysInMonth = new Date(year, month, 0).getDate();
            
            // 3. 批量拉取考勤数据
            for (const user of users) {
                await this.syncUserAttendance(task.companyId, user, year, month, daysInMonth);
                task.processedUsers++;
            }
            
            // 4. 计算月度统计
            await this.recalculateMonthlyStats(task.companyId, task.yearMonth);
            
            task.status = 'completed';
            task.endTime = new Date();
            
        } catch (error) {
            task.status = 'failed';
            task.error = error.message;
            throw error;
        }
    }
    
    private async syncUserAttendance(
        companyId: string, 
        user: any, 
        year: number, 
        month: number, 
        daysInMonth: number
    ): Promise<void> {
        // 调用钉钉API获取考勤数据
        const attendanceData = await this.fetchDingTalkAttendance(companyId, user.userid, year, month);
        
        // 转换并存储每日数据
        for (let day = 1; day <= daysInMonth; day++) {
            const dailyData = this.transformDailyData(attendanceData, day);
            await this.saveDailyAttendance(companyId, user.userid, year, month, day, dailyData);
        }
    }
    
    private transformDailyData(rawData: any, day: number): any {
        // 转换钉钉原始数据为数据库格式
        // ...
    }
    
    private async saveDailyAttendance(
        companyId: string,
        userId: string,
        year: number,
        month: number,
        day: number,
        data: any
    ): Promise<void> {
        // 使用 UPSERT 保存数据
        // ...
    }
}

export const attendanceSyncService = new AttendanceSyncService();
```

### 5.3 增量同步策略

```typescript
// 增量同步：只同步有变化的数据

interface IncrementalSyncConfig {
    // 同步时间窗口
    syncWindowDays: number;  // 默认同步最近7天
    
    // 变更检测
    checkModifiedRecords: boolean;  // 检查修改过的记录
    checkNewApprovals: boolean;     // 检查新审批单
    
    // 触发条件
    autoSyncInterval: number;  // 自动同步间隔（分钟）
    triggerOnApproval: boolean;  // 审批通过时触发
}

async function incrementalSync(companyId: string, yearMonth: string): Promise<void> {
    // 1. 获取上次同步时间
    const lastSyncTime = await getLastSyncTime(companyId, yearMonth);
    
    // 2. 查询有变化的审批单
    const newApprovals = await queryNewApprovals(companyId, lastSyncTime);
    
    // 3. 获取受影响的员工和日期
    const affectedRecords = extractAffectedRecords(newApprovals);
    
    // 4. 只同步受影响的数据
    for (const record of affectedRecords) {
        await syncSingleDayAttendance(companyId, record.userId, record.date);
    }
    
    // 5. 更新同步时间
    await updateLastSyncTime(companyId, yearMonth);
}
```

---

## 6. 缓存策略

### 6.1 多级缓存架构

```
┌─────────────────────────────────────────────────────────────────┐
│                        缓存架构                                  │
└─────────────────────────────────────────────────────────────────┘

  ┌──────────────┐
  │   前端请求   │
  └──────┬───────┘
         │
         ▼
  ┌──────────────┐     命中
  │  内存缓存    │ ─────────▶ 返回
  │  (5分钟)     │
  └──────┬───────┘
         │ 未命中
         ▼
  ┌──────────────┐     命中
  │  IndexedDB   │ ─────────▶ 返回 + 更新内存
  │  (SmartCache)│
  └──────┬───────┘
         │ 未命中
         ▼
  ┌──────────────┐     命中
  │  Redis       │ ─────────▶ 返回 + 更新本地
  │  (1小时)     │
  └──────┬───────┘
         │ 未命中
         ▼
  ┌──────────────┐
  │   数据库     │ ─────────▶ 返回 + 更新所有缓存
  └──────────────┘
```

### 6.2 缓存键设计

```typescript
// 缓存键命名规范
const CACHE_KEYS = {
    // 月度考勤日历
    ATTENDANCE_MAP: (companyId: string, yearMonth: string) => 
        `attendance:calendar:${companyId}:${yearMonth}`,
    
    // 审批单详情
    APPROVAL_DETAIL: (procInstId: string) => 
        `approval:detail:${procInstId}`,
    
    // 月度统计
    MONTHLY_STATS: (companyId: string, yearMonth: string) => 
        `attendance:stats:${companyId}:${yearMonth}`,
    
    // 员工列表
    EMPLOYEE_LIST: (companyId: string) => 
        `employee:list:${companyId}`,
};

// 缓存TTL配置
const CACHE_TTL = {
    ATTENDANCE_MAP: 5 * 60,      // 5分钟
    APPROVAL_DETAIL: 24 * 60 * 60, // 24小时（审批单不常变）
    MONTHLY_STATS: 10 * 60,      // 10分钟
    EMPLOYEE_LIST: 30 * 60,      // 30分钟
};
```

### 6.3 缓存失效策略

```typescript
// 缓存失效触发条件
const CACHE_INVALIDATION_TRIGGERS = {
    // 手动编辑考勤时
    onAttendanceEdit: async (companyId: string, yearMonth: string, userId: string) => {
        await invalidateCache(CACHE_KEYS.ATTENDANCE_MAP(companyId, yearMonth));
        await invalidateCache(CACHE_KEYS.MONTHLY_STATS(companyId, yearMonth));
    },
    
    // 同步完成时
    onSyncComplete: async (companyId: string, yearMonth: string) => {
        await invalidateCache(CACHE_KEYS.ATTENDANCE_MAP(companyId, yearMonth));
        await invalidateCache(CACHE_KEYS.MONTHLY_STATS(companyId, yearMonth));
    },
    
    // 审批单状态变更时
    onApprovalChange: async (procInstId: string) => {
        await invalidateCache(CACHE_KEYS.APPROVAL_DETAIL(procInstId));
    },
};
```

---

## 7. 前端适配改造

### 7.1 数据加载Hook改造

```typescript
// hooks/useAttendanceCalendar.ts

interface UseAttendanceCalendarOptions {
    companyId: string;
    yearMonth: string;
    autoSync?: boolean;
    syncInterval?: number;
}

interface UseAttendanceCalendarResult {
    attendanceMap: AttendanceMap;
    processDataMap: Record<string, any>;
    isLoading: boolean;
    error: Error | null;
    source: 'cache' | 'database' | 'dingtalk';
    lastSyncTime: Date | null;
    sync: (options?: { force?: boolean }) => Promise<void>;
    updateDaily: (userId: string, day: number, data: DailyAttendanceStatus) => Promise<void>;
}

export function useAttendanceCalendar(options: UseAttendanceCalendarOptions): UseAttendanceCalendarResult {
    const { companyId, yearMonth, autoSync = true, syncInterval = 5 * 60 * 1000 } = options;
    
    const [attendanceMap, setAttendanceMap] = useState<AttendanceMap>({});
    const [processDataMap, setProcessDataMap] = useState<Record<string, any>>({});
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState<Error | null>(null);
    const [source, setSource] = useState<'cache' | 'database' | 'dingtalk'>('cache');
    const [lastSyncTime, setLastSyncTime] = useState<Date | null>(null);
    
    // 加载数据
    useEffect(() => {
        loadData();
    }, [companyId, yearMonth]);
    
    // 自动同步
    useEffect(() => {
        if (!autoSync) return;
        
        const interval = setInterval(() => {
            sync({ force: false });
        }, syncInterval);
        
        return () => clearInterval(interval);
    }, [autoSync, syncInterval]);
    
    const loadData = async () => {
        setIsLoading(true);
        setError(null);
        
        try {
            // 1. 尝试从本地缓存加载
            const cacheKey = `ATTENDANCE_MAP_CACHE_${companyId}_${yearMonth}`;
            const cachedData = await SmartCache.get(cacheKey);
            
            if (cachedData) {
                setAttendanceMap(cachedData);
                setSource('cache');
            }
            
            // 2. 从数据库加载最新数据
            const response = await fetch(`/api/v1/attendance/calendar/${companyId}/${yearMonth}`);
            if (response.ok) {
                const result = await response.json();
                setAttendanceMap(result.data.attendanceMap);
                setProcessDataMap(result.data.processDataMap);
                setLastSyncTime(new Date(result.data.syncTime));
                setSource('database');
                
                // 更新本地缓存
                await SmartCache.set(cacheKey, result.data.attendanceMap);
            }
        } catch (err) {
            setError(err as Error);
            // 降级到本地缓存
        } finally {
            setIsLoading(false);
        }
    };
    
    const sync = async (options?: { force?: boolean }) => {
        try {
            const response = await fetch(`/api/v1/attendance/sync/${companyId}/${yearMonth}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    syncType: options?.force ? 'full' : 'incremental',
                    forceRefresh: options?.force
                })
            });
            
            if (response.ok) {
                // 同步完成后重新加载数据
                await loadData();
            }
        } catch (err) {
            console.error('Sync failed:', err);
        }
    };
    
    const updateDaily = async (userId: string, day: number, data: DailyAttendanceStatus) => {
        // 1. 乐观更新本地状态
        setAttendanceMap(prev => ({
            ...prev,
            [userId]: {
                ...prev[userId],
                [day]: data
            }
        }));
        
        // 2. 同步到数据库
        try {
            await fetch(`/api/v1/attendance/daily/${companyId}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    userId,
                    date: `${yearMonth}-${String(day).padStart(2, '0')}`,
                    ...data
                })
            });
            
            // 3. 更新本地缓存
            const cacheKey = `ATTENDANCE_MAP_CACHE_${companyId}_${yearMonth}`;
            await SmartCache.set(cacheKey, attendanceMap);
        } catch (err) {
            // 回滚本地状态
            await loadData();
            throw err;
        }
    };
    
    return {
        attendanceMap,
        processDataMap,
        isLoading,
        error,
        source,
        lastSyncTime,
        sync,
        updateDaily
    };
}
```

### 7.2 双写过渡期策略

```typescript
// 过渡期间同时写入本地缓存和数据库

const FEATURE_FLAGS = {
    USE_DATABASE: false,      // 是否启用数据库
    DUAL_WRITE: true,         // 是否双写
    FALLBACK_TO_CACHE: true,  // 数据库失败时是否降级到缓存
};

async function saveAttendanceData(
    companyId: string, 
    yearMonth: string, 
    data: AttendanceMap
): Promise<void> {
    const cacheKey = `ATTENDANCE_MAP_CACHE_${companyId}_${yearMonth}`;
    
    // 1. 始终写入本地缓存
    await SmartCache.set(cacheKey, data);
    
    // 2. 如果启用数据库，同步写入
    if (FEATURE_FLAGS.USE_DATABASE || FEATURE_FLAGS.DUAL_WRITE) {
        try {
            await fetch(`/api/v1/attendance/calendar/${companyId}/${yearMonth}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ attendanceMap: data })
            });
        } catch (err) {
            console.error('Database write failed:', err);
            // 双写模式下不抛出错误，保证本地缓存可用
            if (!FEATURE_FLAGS.DUAL_WRITE) {
                throw err;
            }
        }
    }
}

async function loadAttendanceData(
    companyId: string, 
    yearMonth: string
): Promise<AttendanceMap | null> {
    // 1. 如果启用数据库，优先从数据库加载
    if (FEATURE_FLAGS.USE_DATABASE) {
        try {
            const response = await fetch(`/api/v1/attendance/calendar/${companyId}/${yearMonth}`);
            if (response.ok) {
                const result = await response.json();
                return result.data.attendanceMap;
            }
        } catch (err) {
            console.error('Database read failed:', err);
            if (!FEATURE_FLAGS.FALLBACK_TO_CACHE) {
                throw err;
            }
        }
    }
    
    // 2. 降级到本地缓存
    const cacheKey = `ATTENDANCE_MAP_CACHE_${companyId}_${yearMonth}`;
    return await SmartCache.get(cacheKey);
}
```

---

## 8. 数据迁移策略

### 8.1 迁移流程

```
┌─────────────────────────────────────────────────────────────────┐
│                        迁移流程图                                │
└─────────────────────────────────────────────────────────────────┘

  ┌──────────┐     ┌──────────┐     ┌──────────┐     ┌──────────┐
  │ 1. 导出  │ ──▶ │ 2. 转换  │ ──▶ │ 3. 校验  │ ──▶ │ 4. 导入  │
  │ 缓存数据 │     │ 数据格式 │     │ 数据完整 │     │ 数据库   │
  └──────────┘     └──────────┘     └──────────┘     └──────────┘
                                                           │
                                                           ▼
                                    ┌──────────┐     ┌──────────┐
                                    │ 6. 清理  │ ◀── │ 5. 验证  │
                                    │ 旧缓存   │     │ 功能正常 │
                                    └──────────┘     └──────────┘
```

### 8.2 迁移脚本

```typescript
// scripts/migrateAttendanceData.ts

interface MigrationResult {
    success: boolean;
    migratedMonths: string[];
    totalRecords: number;
    errors: Array<{ month: string; error: string }>;
}

async function migrateAttendanceDataToDatabase(): Promise<MigrationResult> {
    const result: MigrationResult = {
        success: true,
        migratedMonths: [],
        totalRecords: 0,
        errors: []
    };
    
    // 1. 获取所有缓存的月份数据
    const cacheKeys = await SmartCache.keys('ATTENDANCE_MAP_CACHE_*');
    
    for (const key of cacheKeys) {
        // 解析 key: ATTENDANCE_MAP_CACHE_{companyId}_{yearMonth}
        const parts = key.split('_');
        const companyId = parts[3];
        const yearMonth = parts[4];
        
        try {
            // 2. 读取缓存数据
            const attendanceMap = await SmartCache.get(key);
            if (!attendanceMap) continue;
            
            // 3. 转换并写入数据库
            const records = await transformAndSave(companyId, yearMonth, attendanceMap);
            
            result.migratedMonths.push(`${companyId}/${yearMonth}`);
            result.totalRecords += records;
            
        } catch (error) {
            result.success = false;
            result.errors.push({ 
                month: `${companyId}/${yearMonth}`, 
                error: String(error) 
            });
        }
    }
    
    return result;
}

async function transformAndSave(
    companyId: string, 
    yearMonth: string, 
    attendanceMap: AttendanceMap
): Promise<number> {
    let recordCount = 0;
    const [year, month] = yearMonth.split('-').map(Number);
    
    for (const [userId, dailyMap] of Object.entries(attendanceMap)) {
        for (const [day, dailyStatus] of Object.entries(dailyMap)) {
            // 转换为数据库格式
            const dbRecord = {
                company_id: companyId,
                user_id: userId,
                attendance_date: `${yearMonth}-${String(day).padStart(2, '0')}`,
                year_month: yearMonth,
                status: dailyStatus.status,
                has_abnormality: dailyStatus.hasAbnormality,
                on_duty_time: dailyStatus.onDutyTime,
                off_duty_time: dailyStatus.offDutyTime,
                // ... 其他字段
            };
            
            // 写入数据库
            await insertOrUpdateDailyAttendance(dbRecord);
            
            // 写入打卡记录
            for (const record of dailyStatus.records) {
                await insertPunchRecord(dbRecord.id, record);
            }
            
            recordCount++;
        }
    }
    
    return recordCount;
}
```

---

## 9. 权限控制设计

### 9.1 权限矩阵

| 角色 | 查看日历 | 编辑考勤 | 触发同步 | 查看统计 | 导出数据 | 查看日志 |
|------|----------|----------|----------|----------|----------|----------|
| 超级管理员 | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
| 公司管理员 | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
| HR主管 | ✅ | ✅ | ✅ | ✅ | ✅ | ❌ |
| HR专员 | ✅ | ❌ | ❌ | ✅ | ✅ | ❌ |
| 部门主管 | ✅(本部门) | ❌ | ❌ | ✅(本部门) | ✅(本部门) | ❌ |
| 普通员工 | ✅(本人) | ❌ | ❌ | ✅(本人) | ❌ | ❌ |

### 9.2 权限码定义

```typescript
export const ATTENDANCE_CALENDAR_PERMISSIONS = {
    VIEW: 'attendance:calendar:view',
    VIEW_ALL: 'attendance:calendar:view_all',
    EDIT: 'attendance:calendar:edit',
    SYNC: 'attendance:calendar:sync',
    STATS: 'attendance:stats:view',
    EXPORT: 'attendance:export',
    AUDIT_LOG: 'attendance:audit_log:view'
} as const;
```

---

## 10. 实施计划

### 10.1 阶段划分

| 阶段 | 内容 | 时间 | 交付物 |
|------|------|------|--------|
| 第一阶段 | 数据库设计与建表 | 1周 | DDL脚本、ER图 |
| 第二阶段 | 后端API开发 | 2周 | API接口、单元测试 |
| 第三阶段 | 同步服务开发 | 1周 | 同步服务、任务调度 |
| 第四阶段 | 前端适配改造 | 1周 | 前端代码、集成测试 |
| 第五阶段 | 数据迁移与双写 | 1周 | 迁移脚本、监控面板 |
| 第六阶段 | 灰度发布与验证 | 1周 | 灰度方案、回滚预案 |
| 第七阶段 | 全量切换与清理 | 1周 | 清理脚本、文档更新 |

### 10.2 风险与应对

| 风险 | 影响 | 应对措施 |
|------|------|----------|
| 数据迁移失败 | 历史数据丢失 | 迁移前备份、支持回滚 |
| 钉钉API限流 | 同步失败 | 限流控制、重试机制 |
| 数据库性能问题 | 页面加载慢 | 多级缓存、分页查询 |
| 并发编辑冲突 | 数据覆盖 | 乐观锁、版本号校验 |
| 统计计算耗时 | 用户等待 | 异步计算、预计算 |

### 10.3 回滚方案

```typescript
// 紧急回滚脚本
async function emergencyRollback() {
    // 1. 关闭数据库写入
    await setFeatureFlag('attendance_calendar_db_write', false);
    
    // 2. 切换前端读取源为本地缓存
    await setFeatureFlag('attendance_calendar_source', 'cache');
    
    // 3. 停止同步任务
    await stopAllSyncTasks();
    
    // 4. 通知相关人员
    await sendAlert('考勤日历数据已回滚到本地缓存模式');
}
```

---

## 11. 附录

### 11.1 完整建表脚本

所有建表语句已在第3节详细列出，可直接执行。

### 11.2 数据字段映射表

| 前端字段 | 数据库字段 | 类型 | 说明 |
|----------|------------|------|------|
| status | status | ENUM | 考勤状态 |
| onDutyTime | on_duty_time | TIME | 上班时间 |
| offDutyTime | off_duty_time | TIME | 下班时间 |
| hasAbnormality | has_abnormality | BOOLEAN | 是否异常 |
| records | punch_record表 | 1:N | 打卡记录 |
| lateMinutes | late_minutes | INT | 迟到分钟数 |
| isFullAttendance | is_full_attendance | BOOLEAN | 是否全勤 |

### 11.3 与考勤规则配置的关联

本方案与《考勤规则配置入库技术方案》相互配合：
- 考勤规则配置决定如何计算迟到、全勤等
- 考勤日历数据存储实际的考勤记录
- 月度统计基于规则配置计算生成

两个方案共享：
- 公司标识 (company_id)
- 员工标识 (user_id)
- 权限控制体系
- 缓存策略
